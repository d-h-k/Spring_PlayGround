## 로그 추적기 요구사항 분석
- 병목지점, 예외 터지는 부분을 분석하고 찾아내기 위한 로그추적기 시스템을 개발해야함
- 
- 
- 
- 트랜잭션 아이디도 추적(같은 요청에는 같은 ID)
d

## UUID
TraceId 를 처음 생성하면 createId() 를 사용해서 UUID를 만들어낸다. UUID가 너무 길어서 여기서는
앞 8자리만 사용한다. 이 정도면 로그를 충분히 구분할 수 있다. 여기서는 이렇게 만들어진 값을 트랜잭션ID
로 사용한다.
ab99e16f-3cde-4d24-8241-256108c203a2 //생성된 UUID
ab99e16f //앞 8자리만 사용


## UUID 란?
- 네트워크 상에서 고유성이 보장되는 id를 만들기 위한 표준 규약이다. UUID는 Universally Unique IDentifier의 약어이고 범용 고유 식별자라고 한다. 주로 분산 컴퓨팅 환경에서 사용되는 식별자
- https://docs.oracle.com/javase/1.5.0/docs/api/java/util/UUID.html
- 


## 12월 26일 스터디 정리

- 동시성 이슈 발생시키기
- 동시성 문제 발생하는거 확인
  - 왜 발생하냐면 FieldLogTrace 는 싱글톤으로 등록된 스프링 빈이다. 이 객체의 인스턴스가 애플리케이션에 딱 하나만존재한다는 뜻이다. 이렇게 하나만 있는 인스턴스의 FieldLogTrace.traceIdHolder 필드를 여러
  쓰레드가 동시에 접근하기 때문에 문제가 발생한다.
  실무에서 한번 나타나면 개발자를 가장 괴롭히는 문제도 바로 이러한 동시성 문제이다


## AOP 미리보기
- 따라갈수 없다면 앞질러가겠어..
- 여러 클래스에 나뉘어있는 책임을 Aspect: 관점이라고 부르는데
- 이 Aspect 를 별도의 클래스에 몰아넣는(캡슐화) 하는 접근 방식을 AOP 라고 합니다
- 여러 클래스에 나뉘어있는 책임을 Aspect라고 했는데, 또다른 용어로 횡단 관심사(cross-cutting concern) 이라고도 하는데
  - 대표적으로 로깅, 트랜잭션 관리, 캐싱, 보안(인증인가 세션처리 등등)
- 용어가 이거같은데(의견 감사합니당)
  - 기술 장르 : ORM > AOP
  - 스프링에서 : JPA > Spring-AOP
  - 내부구현체 : 하이버네이트 > eclipse-aspectJ

### AOP 주요용어
- Advice : 횡단관심사를 구현하는 애스팩트의 메서드
- 포인트컷 : 각각의 어드바이스들이 그 어드바이스를 적용할 메서드를 구별하는 기준
- 조인 포인트 : 어드바이스를 적용할 메서드
- 스프링 AOP 프레임워크는 프록시 기반
  - 프록시 : JPA 에서도 나옴(아래 설명)
  - 어드바이스 대상 객체마다 프록시가 만들어진다

### 예시
```java
@ControllerAdvice // 1 - AOP 라는거
@Slf4j
public class ExceptionControllerAdvice {//관례적으로 Advice 라고 붙여줌 

    @ExceptionHandler({OutOfDateException.class}) // 포인트컷, 이 예외 발생시 사용
    public ResponseEntity<?> handleAccessDeniedException(final OutOfDateException e) {
        log.warn("OutOfDateException {}", e.getMessage()); //이 메서드는 조인포인트
        return ResponseEntity.status(HttpStatus.METHOD_NOT_ALLOWED).body(e.getMessage());
    }
    
}
```


### 프록시..
- 어디서씀?
  - AOP : 도 프록시를 쓴다고 하고
  - JPA : 에서 연관 객체들 처음부터 데이터베이스에서 조회하는 것이 아니라, 실제 사용하는 시점에 조회하는지 아닌지 설정하는게 즉시로딩 ( EAGER ) 과 지연로딩 ( LAZY ) 인데 이와 관련 된 기술이 프록시 인데, 이 프록시를 통해서
  - 트랜잭션(디비)

- 왜씀? Proxy를 사용하는 이유
  - OCP(Open - Closed Principle)을 지키기 위해서 사용합니다
  - 개방 폐쇄 원칙 확장에 대해서는 열려있어야 하고, 수정에 대해서는 닫혀있다
  - (좀더 친절하게) 기획자가 요구를 바꾸더라도 기존 구성요소는 수정이 일어나면 안됨
  - 기존 구성요소를 확장해서 기능을 추가하고 확장하는게 쉬워야 한다
  - 변하는것과 변화하지 않는것을 분리(변경주기가 같은것과 다른것을 뜯어내고) >> 이 분리한 생명주기 다른것 끼리 인터페이스-클래스로 연결해주고
  - 구체화(클래스) 에 의존하기보다 추상화
  - https://huisam.tistory.com/entry/springAOP


<br><br><br>


## 22년 1월 4일, 3주차(템플릿 메서드 패턴과 콜백패턴)

<br><br><br>

### 템플릿 메서드 패턴 왜 도입한건가

- 좋은 설계는??  :   요구사항 변경(기능추가)이 일어났을때 비로소 알게된다
  - 기존 V3 까지는 TraceLog Logic 에 변경이 발생하면 모든 Tier(repo,service,con) 에 찾아 돌아다니면서 일일이 수정해야한다면
  - V4 는 Template-Method 패턴을 사용해서 한군데만 고쳐도 모든 부분에 수정된 TraceLog Logic 가 적용된다
  - 한마디로 단일 책임 원칙(SRP) 지킴! : 변경 지점을 하나로 모아서 변경에 쉽게 대처할수 있는 구조
    - 뒤집어서 말하면, TraceLog Logic 에 대한 책임이 사용처에 분산되어 있는게 아니라 TraceLog 그 자체에 집중되어 있다

- 템플릿 메서드 패턴
  - 설명 : 템플릿을 만들어서 99%정도 코드(대부분/골격)를 만들어 놓고 일부단계만 하위 클래스한테 위임(연기) 함
  - 어떻게 만들지?
    - 1% 차이가 나는 단계를 동일한 시그너처를 가진 메소드로 만들어서 분리하고 > 메서드를 재정의 해서 차이나는 부분만 구현
    - 99% 동일한 부분은 수퍼클래스로 올린다
  - 정리 : 99%공통부분 상위(템플릿)으로 올리고, 1%차이는 하위클래스로 내려서, 변하는것과 변하지 않는것의 분리가 핵심
    - 상속을 통해서 99% 공통점/중복 제거



## 템플릿 메서드 패턴
- 인트로 (이전화 이야기) : 쓰레드로컬로 로그추적기 기능을 구현했는데, 도입하려고 보니까 개발자들이 엄청 싫어한다. 왜 그럴까??
- 쓰레드로컬로 기능구현한 로그추적기가 구린 이유는 
  - 쓰레드로컬 기능을 사용해도 여전히 기존에 로직들이 들어있던 코드에 try~ catch 문이 필요한건 여전했고(로그남기는 로직 + 보일러플레이트 코드)가 덕지덕지 붙어있는 배보다 배꼽이 큰 코드들이 있었다
- V0버전을 돌이켜봤을때 핵심기능만 있는 코드보다 더러운건 어쩔수 없다.
- 부가기능때문에 코드가 덕지덕지 붙음
- (사견)remove 를 정확한곳에 쓰레드마다 꼭 사용해줘야하는 책임은 여전히 로그추적기가 담당하는게 아니라, 개발자들의 몫이였다

### 핵심기능과 부가기능
- 핵심기능 : 고유기능 (Order/주문하기)
- 부가기능 : 로그 남기기
- 지금 V3 버전의 코드는 핵심기능보다 부가기능의 코드가 훨씬 많다. 배보다 배꼽이 큰 상황
- 부가기능인 로그 남기기 때문에 코드가 지저분해지고 라인도 늘어나니까 >> 도입하려는 개발자들이 싫어하는건 당연한일 

```java
TraceStatus status = null;
try {
    status = trace.begin("message");
    //핵심 기능 호출하는 부분
        //
    // repo : 저장, controller : 서비스호출 , service : 로직처리
    trace.end(status);
} catch (Exception e) {
    trace.exception(status, e);
    throw e;
}
```
- V3 버전의 코드를 전체적으로 살펴보면 3tier (repo/controller/service) 친구들 모두 비슷비슷하게 생겼다
- try{} 블럭 사이에 핵심기능만 조금 다르고 나머지는 비슷하기 때문
- 이 핵심기능과 부가기능을 분리해내면 어떨까? 당연히 트라이캐치문도 있고해서 쉽지는 않다만..

### 결론
- 핵심기능과 부가기능을 분리해내야하고
- 쉽게 변하는것과, 변화하지 않는부분을 분리해내기
- 템플릿 메서드 패턴은 두 계층을 서로 분리하고 모듈화하기 위해 사용되는 디자인 패턴이다!


<br><br><br>

## **V**oid 클래스
- package java.lang.Void 클래스 이야기
```java
public final class Void {
    ~~
}
```

- void 가 아니라 >> Void 클래스 라는게 있습니다
  - (번역기) Void 클래스는 보관할 인스턴스화할 수 없는 자리 표시자 클래스입니다. Java 키워드를 나타내는 {@code Class} 객체에 대한 참조
  - Void 클래스는 플레이스홀더 클래스 (=자리만 차지하라고 만들어주는 클래스)
    - Java 예약어 void 를 나타대는 Class 객체에 대한 참조를 유지하기 위해서
    - 생성할 수 없는 플레이스 홀더 클래스
  - void 키워드에 해당하는 pseudo-type 을 나타내는 Class 객체
    - 실체화할수 없음 (아래 생성자 코드 참고)
    ```
    public static final Class<Void> TYPE = (Class<Void>) Class.getPrimitiveClass("void");
    ```
- 요런거 어디다 쓰냐??? 두가지가 있슴당
  - 1) 자바 리플렉션 에서 반환값을 판별하기 위해 사용되고
    -
  - 2) 제네릭 클래스를 구현할 때 사용됩니다

<br><br><br><br>


### 이번단원 정리
- OrderServiceV0 : 핵심 기능만 있다 (하지만 로깅 기능이 없다)
  - V1,V2 기능구현하고 버그잡고..
- OrderServiceV3 : 핵심 기능과 부가 기능이 함께 섞여 있다 (코드가 상당히 지저분하고 배보다 배꼽이 크다)
- OrderServiceV4 : 핵심 기능과 템플릿을 호출하는 코드가 섞여있다 (V3보다는 훨씬 개선됬는데, 여전히 매 클라이언트 마다마다 추가할 코드는 있다
의미 : V4는 템플릿 메서드 패턴을 사용해서 [핵심 기능] // [부가기능] 을 두가지를 조금이나 분리 해낼 수 있고  >> 핵심기능에 집중할 수 있다


### 면접카운터 
- 템플릿 메서드 패턴 : 두가지만 기억해주세요 (분리, 상속)
  - 분리 : 반복되는부분과(템플릿), 매번 달라지는 부분, 변경주기가 다른것들끼리 분리해내는거
  - 상속 : 달라지는 부분을 자식클래스로, 상속이 단점이야(강하게 결합, 부모클래스를 하나도 안쓰는데 모두다 물려받아야되)
- 전략패턴 : 어떻게 동작할지에 대한 전략(Strategy) 를 외부에서 입력받는 방식
  - 선조립 후실행 방식으로 구현하면 동적으로 전략을 변경하기 힘들다 (final 키워드 선언, 생성시 주입받음)
  - 전략을 동적으로 변경하려면 Setter 를 만들면 되는데 싱글톤에서 공유변수를 만드는게 상당히 위험한 짓이라 비추
  - 전략을 동적으로 변경하기 위해서 실행시 파라미터를 매번 입력받는 전략패턴
  - 이펙티브 자바 아이템 18,20 (18-상속보다 컴포지션, 20-추상클래스보다는 인터페이스)
